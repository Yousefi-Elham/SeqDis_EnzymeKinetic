#Ds for non comp,when theta is thEstart,thEstart[1:3]
par(mfrow=c(1,1))
rm(list=ls())
set.seed(123456789)
library(BB)
library(mgcv)
library(stats)
library(plotfunctions)
library(numDeriv)
library(MASS) #generalized inverse

xstart = matrix(c(0.00, 0.00,
                  0.00, 30.00,
                  0.00, 60.00,
                  15.00, 0.00,
                  15.00, 30.00,
                  15.00, 60.00,
                  30.00, 0.00,
                  30.00, 30.00,
                  30.00, 60.00), nrow=9,ncol=2,byrow=TRUE)


xstart1=xstart[,1]
xstart2=xstart[,2]

n <- nrow(xstart)
wstart=c(rep((1/n),n))

th0start <- c(7.298, 4.386, 2.582)
s0start <- c(0.114, 0.233, 0.145)
th1start <- c(8.696, 8.066, 12.057)
s1start<- c(0.222, 0.488, 0.671)

thEstart <- c(7.4253, 4.6808, 3.0581,0.9636)
sEstart <- c(0.1298, 0.2724, 0.2815,0.0191)


TH0START<-c(7.298, 4.386, 2.582)
TH1START<- c(8.696, 8.066, 12.057)
SIG0<-0.1553
SIG1<-0.2272

THESTART <- c(7.4253, 4.6808, 3.0581,0.9636)
SIGE<-0.1526


x1g=seq(0,30,length=31)
x2g=seq(0,60,length=61)
grid=expand.grid(x1g,x2g)


iter=0
max.iter=5000


colfunc <- colorRampPalette(c("lightblue","cornflowerblue", "darkblue"))
colorgrad <- colfunc(max.iter)

THETA.HAT=matrix(0,max.iter,4)
THETA.HATBBo=matrix(0,max.iter,4)
th1l=th0l=th0u=th1u=matrix(0,max.iter,3)
num.max=numeric(max.iter)
maxdev.vec=sigmaEhat=sigma1hat=numeric(max.iter)

####################################################

# Model 0  (comp)
f0 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kic <- th[3]
  V * S / (Km * (1 + I/Kic) + S)
}

# Model 1  (non comp)
f1 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kin <- th[3]
  V * S / ((Km + S) * (1 + I/Kin))
}

# Model 2  (encompassing)
fE <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Klm <- th[3]
  Lmbda <- th[4]
  V * S / ( Km *(1+I/Klm) + S * (1 + (1-Lmbda) * I/Klm))
}

#-------------------------------------------------------
SE1 <- 0
S11 <- 0
########################################################

par(mar=c(5.1, 4.1, 4.1, 4.1))
plot(xstart1, xstart2, type = "n",xlab="x1",ylab="x2",pch=16,col="blue"); grid()
points(xstart1, xstart2,col=colorgrad[1], pch=16,cex=0.3)

gradientLegend(valRange=c(1,max.iter),color = c("lightblue","cornflowerblue", "darkblue"),
               nCol = 3,inside = FALSE, pos=.825,dec = 0,n.seg=3)
#text(x=31.5, y = 62, lables=expression("Tttitle"))


y<-f0(xstart1, xstart2, TH0START)+rnorm(nrow(xstart), sd = SIG0)
for(i in 1:length(y)){
  if(y[i]<0) y[i]<-0
}

basia<-data.frame(y,xstart)
#------------------------------------------------------------------

while(iter< max.iter){
  iter=iter+1
  print(iter)
  #-----------------------------------------------------------------------------------------------------------------------
  #                                                        Theta.HAT
  #-----------------------------------------------------------------------------------------------------------------------  
  
  mEpar.est<-nls(y~b1*basia[,2]/(b2*(1+basia[,3]/b3)+basia[,2]*(1+(1-b4)*basia[,3]/b3)),algorithm="port",lower=c(0.001,0.001,0.001,0.0001),upper=c(Inf,Inf,Inf,1), start= list(b1=thEstart[1],b2=thEstart[2],b3=thEstart[3],b4=thEstart[4]), data=basia)
  THETA.HAT[iter,]<-summary(mEpar.est)$parameters[,1]
  sigmaEhat[iter]<-sqrt(sum(residuals(mEpar.est)^2)/(nrow(basia)-4))
  
  
  #-----------------------------------------------------------------------------------------------------------------------
  #                                                        X.HAT
  #-----------------------------------------------------------------------------------------------------------------------  
  
  #-----------------------------------------------------
  F0.full <- matrix(0, nrow = nrow(xstart), ncol = 3)
  F1.full <- matrix(0, nrow = nrow(xstart), ncol = 3)
  FE3.full <- matrix(0, nrow = nrow(xstart), ncol = 3)
  FE.full <- matrix(0, nrow = nrow(xstart), ncol = 4)
  
  x1 <- xstart[,1]
  x2 <- xstart[,2]
  
  
  #a <- thEstart[1] * x1 
  #b <- 1 + x2 / thEstart[3]
  #d <- b * thEstart[2] + x1
  #F0.full[,1] <- x1 / d
  #F0.full[,2] <- -a / d^2 * b
  #F0.full[,3] <- a / d^2 * (thEstart[2] * x2 / thEstart[3]^2)
  
  
  #a <- thEstart[1] * x1 
  #b <- 1 + x2 / thEstart[3]
  #d <- b * (thEstart[2] + x1)
  #F1.full[,1] <- x1 / d
  #F1.full[,2] <- -a / d^2 * b
  #F1.full[,3] <- a / d^2 * ((thEstart[2] + x1) * x2 / thEstart[3]^2)
  
  
  a <- thEstart[1] * x1 
  b <- 1 + x2 / thEstart[3]
  cc <- 1 + (1-0.9636) * x2 / thEstart[3]
  d <- (b * thEstart[2]) + (x1 * cc)
  FE3.full[,1] <- x1 / d
  FE3.full[,2] <- -a / d^2 * b
  FE3.full[,3] <- a / d^2 * ((thEstart[2] + x1 * (1-0.9636)) * x2 / thEstart[3]^2)
  
  
  
  a <- thEstart[1] * x1 
  b <- 1 + x2 / thEstart[3]
  cc <- 1 + (1-thEstart[4]) * x2 / thEstart[3]
  d <- (b * thEstart[2]) + (x1 * cc)
  FE.full[,1] <- x1 / d
  FE.full[,2] <- -a / d^2 * b
  FE.full[,3] <- a / d^2 * ((thEstart[2] + x1 * (1-thEstart[4])) * x2 / thEstart[3]^2)
  FE.full[,4] <- a / d^2 * (x1 * x2 / thEstart[3] )
  
  
  #W <- diag(wstart)
  M.mat <- t(FE.full) %*% FE.full
  ME3.mat <- t(FE3.full) %*% FE3.full  
  
  
  ds.funct<-function(xx1,xx2){
    
    f0.full <- matrix(0, nrow = 1, ncol = 3)
    f1.full <- matrix(0, nrow = 1, ncol = 3)
    fE3.full <- matrix(0, nrow = 1, ncol = 3)
    fE.full <- matrix(0, nrow = 1, ncol = 4)
    
    #a <- thEstart[1] * xx1 
    #b <- 1 + xx2 / thEstart[3]
    #d <- b * thEstart[2] + xx1
    #f0.full[1] <- xx1 / d
    #f0.full[2] <- -a / d^2 * b
    #f0.full[3] <- a / d^2 * (thEstart[2] * xx2 / thEstart[3]^2)
    
    
    #a <- thEstart[1] * xx1 
    #b <- 1 + xx2 / thEstart[3]
    #d <- b * (thEstart[2] + xx1)
    #f1.full[1] <- xx1 / d
    #f1.full[2] <- -a / d^2 * b
    #f1.full[3] <- a / d^2 * ((thEstart[2] + xx1) * xx2 / thEstart[3]^2)
    
    
    a <- thEstart[1] * xx1 
    b <- 1 + xx2 / thEstart[3]
    cc <- 1 + (1-0.9636) * xx2 / thEstart[3]
    d <- (b * thEstart[2]) + (xx1 * cc)
    fE3.full[1] <- xx1 / d
    fE3.full[2] <- -a / d^2 * b
    fE3.full[3] <- a / d^2 * ((thEstart[2] + xx1 * (1-0.9636)) * xx2 / thEstart[3]^2)
    
    
    a <- thEstart[1] * xx1 
    b <- 1 + xx2 / thEstart[3]
    cc <- 1 + (1-thEstart[4]) * xx2 / thEstart[3]
    d <- (b * thEstart[2]) + (xx1 * cc)
    fE.full[1] <- xx1 / d
    fE.full[2] <- -a / d^2 * b
    fE.full[3] <- a / d^2 * ((thEstart[2] + xx1 * (1-thEstart[4])) * xx2 / thEstart[3]^2)
    fE.full[4] <- a / d^2 * (xx1 * xx2 / thEstart[3] )
    
    
    xx=matrix(c(xx1,xx2),1,2)
    
    d<-fE.full%*%ginv(M.mat)%*%t(fE.full)-fE3.full%*%ginv(ME3.mat)%*%t(fE3.full)
    d
  }
  d.value<-mapply(ds.funct,grid[,1],grid[,2])
  
  maxdev.vec[iter]<-max(d.value)
  xnew<-c(grid[which.max(d.value),1],grid[which.max(d.value),2])
  
  #-----------------------------------------------------
  xstart<-rbind(xstart,xnew)
  ynew<-f0(xnew[1], xnew[2], TH0START)+rnorm(1, sd = SIG0)
  if(ynew<0) ynew<-0
  
  y<-c(y,ynew) 
  
  
  cexxx=(length(which(xstart[,1]==xnew[1]&xstart[,2]==xnew[2])))^(1/2)
  points(xnew[1], xnew[2], type = "p",col=colorgrad[iter], pch=16,cex=0.3*cexxx )
  
  basia<-data.frame(y,xstart)
  
  alpha=1/(iter+1)
  wstart=c(((1-alpha)*wstart),alpha)
  design=cbind(xstart,wstart)
  n=nrow(xstart)
  
  #delta.0=phi(theta.hat)
  #psi.0=xhat.func(x.hat[1],x.hat[2])
  #efficiency[iter]=delta.0/psi.0
  
} 
#----------------------------------------------------------------
design1.uniq=uniquecombs(xstart)
count1=attr(design1.uniq,"index")
count2=unique(sort(count1))
#----------------------------------------------------------------
counter=counter2=numeric(nrow(design1.uniq))
for(j in 1:length(count2)){
  m=which(count1==count2[j])
  #weight[j]=sum(design[m,3])
  counter[j]=length(m)
  counter2[j]=length(m)/max.iter
}
#----------------------------------------------------------------
design.opt=cbind(design1.uniq,counter,counter2)
design.optF <- as.data.frame(design.opt)
design.optF
#################################
cc1<-which(y==0)
sum(cc1) 

cc2<-numeric(length(THESTART))
for(k in 1:length(THESTART)){
  ccc<-which(THETA.HAT[,k]==0.001)
  cc2[k]<-sum(ccc) 
} 
cc2
################################

SIG0
min(sigmaEhat)
max(sigmaEhat)


par(mfrow=c(1,1))
plot(seq(1:max.iter),maxdev.vec , type = "p",xlab="iter",ylab="Max.sensitivity",pch=16,col="blue")
plot(seq(1:max.iter), sigmaEhat,ylim=c(0,0.2), type = "p",xlab="iter",ylab=expression(sigma[2]),pch=16,col="blue")
abline(h=SIG0,lty=2,col="red")
#################################
TH0START
min(THETA.HAT[,1])
max(THETA.HAT[,1])

min(THETA.HAT[,2])
max(THETA.HAT[,2])

min(THETA.HAT[,3])
max(THETA.HAT[,3])

min(THETA.HAT[,4])
max(THETA.HAT[,4])

par(mfrow=c(1,1))
plot(seq(1:max.iter),THETA.HAT[,1] ,ylim=c(7,8), type = "p",xlab="iter",ylab=expression(theta[21]),pch=16,col="blue")
abline(h=TH0START[1],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,2] ,ylim=c(4.0,6), type = "p",xlab="iter",ylab=expression(theta[22]),pch=16,col="blue")
abline(h=TH0START[2],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,3] ,ylim=c(2,4), type = "p",xlab="iter",ylab=expression(theta[23]),pch=16,col="blue")
abline(h=TH0START[3],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,4] ,ylim=c(0,1), type = "p",xlab="iter",ylab=expression(lambda),pch=16,col="blue")
#abline(h=THESTART[4],lty=2,col="red")




