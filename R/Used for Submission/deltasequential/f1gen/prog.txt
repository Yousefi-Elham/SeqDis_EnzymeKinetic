#method4-sse-eta-nls-f1

#Delta seq noncompat
par(mfrow=c(1,1))
rm(list=ls())
set.seed(123456789)
library(BB)
library(mgcv)
library(bvls)
library(stats)
library(plotfunctions)

xstart = matrix(c(0.00, 0.00,
                  0.00, 30.00,
                  0.00, 60.00,
                  15.00, 0.00,
                  15.00, 30.00,
                  15.00, 60.00,
                  30.00, 0.00,
                  30.00, 30.00,
                  30.00, 60.00), nrow=9,ncol=2,byrow=TRUE)


xstart1=xstart[,1]
xstart2=xstart[,2]

#xstart=basia
#N=nrow(xstart)
#y<-basia[,1]

#basia<-data.frame(y,xstart)
#wstart=c(rep((1/n),n))
th0start <- c(7.298, 4.386, 2.582)
s0start <- c(0.114, 0.233, 0.145)
th1start <- c(8.696, 8.066, 12.057)
s1start<- c(0.222, 0.488, 0.671)

TH0START<-c(7.298, 4.386, 2.582)
TH1START<- c(8.696, 8.066, 12.057)
SIG0<-0.1553
SIG1<-0.2272

x1g=seq(0,30,length=31)
x2g=seq(0,60,length=61)
grid=expand.grid(x1g,x2g)


iter=0
max.iter=5000


colfunc <- colorRampPalette(c("lightblue","cornflowerblue", "darkblue"))
colorgrad <- colfunc(max.iter)

THETA.HAT=matrix(0,max.iter,6)
th1l=th0l=th0u=th1u=matrix(0,max.iter,3)
num.max=numeric(max.iter)
maxdev.vec=sigma0hat=sigma1hat=cexxx=numeric(max.iter)

# Model 0  (comp)
f0 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kic <- th[3]
  V * S / (Km * (1 + I/Kic) + S)
}

# Model 1  (non comp)
f1 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kin <- th[3]
  V * S / ((Km + S) * (1 + I/Kin))
}


par(mar=c(5.1, 4.1, 4.1, 4.1))
plot(xstart1, xstart2, type = "n",xlab="x1",ylab="x2",pch=16,col="blue"); grid()
points(xstart1, xstart2,col=colorgrad[1], pch=16,cex=0.3)

gradientLegend(valRange=c(1,max.iter),color = c("lightblue","cornflowerblue", "darkblue"),
               nCol = 4,inside = FALSE, pos=.825,dec = 0,n.seg=3)
#text(x=31.5, y = 62, lables=expression("Tttitle"))


y<-f1(xstart1, xstart2, TH1START)+rnorm(nrow(xstart), sd = SIG1)
for(i in 1:length(y)){
  if(y[i]<0) y[i]<-0
}

basia<-data.frame(y,xstart)

while(iter< max.iter){
  iter=iter+1
  print(iter)
  #plot(iter,xlim=c(iter-1,iter+1))
  #text(x=iter+1,y=iter,iter,col="red")
  
  
  m0par.est<-nls(y~b1*basia[,2]/(b2*(1+basia[,3]/b3)+basia[,2]),algorithm="port",lower=c(0.001,0.001,0.001),upper=c(Inf,Inf,Inf), start= list(b1=th0start[1],b2=th0start[2],b3=th0start[3]), data=basia)
  THETA.HAT[iter,1:3]=th0start<-summary(m0par.est)$parameters[,1]
  s0start<-summary(m0par.est)$parameters[,2]
  sigma0hat[iter]<-sqrt(sum(residuals(m0par.est)^2)/(nrow(basia)-3))
  
  #-------------------------------------------------
  m1par.est<-nls(y~b1*basia[,2]/((b2+basia[,2])*(1+basia[,3]/b3)),algorithm="port",lower=c(0.001,0.001,0.001),upper=c(Inf,Inf,Inf), start= list(b1=th1start[1],b2=th1start[2],b3=th1start[3]), data=basia)
  THETA.HAT[iter,4:6]=th1start<-summary(m1par.est)$parameters[,1]
  s1start<-summary(m1par.est)$parameters[,2]
  sigma1hat[iter]<-sqrt(sum(residuals(m1par.est)^2)/(nrow(basia)-3))
  
  #-------------------------------------------------  
  th0l[iter,]<-th0start-1*s0start
  th0u[iter,]<-th0start+1*s0start
  th1l[iter,]<-th1start-1*s1start
  th1u[iter,]<-th1start+1*s1start
  
  
  
  delta.func=function(xdes1,xdes2){
    F0.full <- matrix(0, nrow = 1, ncol = 3)
    a0.full <- rep(0, 1)
    F1.full <- matrix(0, nrow = 1, ncol = 3)
    a1.full <- rep(0, 1)
    
    
    x1 <- xdes1
    x2 <- xdes2
    
    a <- th0start[1] * x1 
    b <- 1 + x2 / th0start[3]
    d <- b * th0start[2] + x1
    F0.full[1] <- x1 / d
    F0.full[2] <- -a / d^2 * b
    F0.full[3] <- a / d^2 * (th0start[2] * x2 / th0start[3]^2)
    a0.full <- a / d - sum(F0.full * th0start)
    
    a <- th1start[1] * x1 
    b <- 1 + x2 / th1start[3]
    d <- b * (th1start[2] + x1)
    F1.full[1] <- x1 / d
    F1.full[2] <- -a / d^2 * b
    F1.full[3] <- a / d^2 * ((th1start[2] + x1) * x2 / th1start[3]^2)
    a1.full <- a / d - sum(F1.full * th1start)
    
    crit_delta_sq<-bvls(cbind(F0.full, -F1.full), a1.full - a0.full, c(th0l[iter,],th1l[iter,]), c(th0u[iter,],th1u[iter,]))$deviance
    
    crit_delta_sq
    
    
  }
  delta.values=mapply(delta.func,grid[,1],grid[,2])
  maxdev.vec[iter]<-max(delta.values)
  xnew<-c(grid[which.max(delta.values),1],grid[which.max(delta.values),2])
  xstart<-rbind(xstart,xnew)
  
  
  ynew<-f1(xnew[1], xnew[2], TH1START)+rnorm(1, sd = SIG1)
  if(ynew<0) ynew<-0
  
  
  y<-c(y,ynew) 
  
  
  
  cexxx=(length(which(xstart[,1]==xnew[1]&xstart[,2]==xnew[2])))^(1/2)
  points(xnew[1], xnew[2], type = "p",col=colorgrad[iter], pch=16,cex=0.3*cexxx )
  
  
  
  #sp2<-ggplot(data.frame(xstart1,xstart2), aes(x=xstart1, y=xstart2, color=1))+ geom_point()+geom_point(x=xnew[1], y=xnew[2],aes(x=xnew[1], y=xnew[2], color=iter))
  #sp2+scale_color_gradient(low="lightblue", high="darkblue")
  
  
  basia<-data.frame(y,xstart)
  
  
}

design1.uniq=uniquecombs(xstart)
count1=attr(design1.uniq,"index")
count2=unique(sort(count1))
#----------------------------------------------------------------
counter=counter2=numeric(nrow(design1.uniq))
for(j in 1:length(count2)){
  m=which(count1==count2[j])
  #weight[j]=sum(design[m,3])
  counter[j]=length(m)
  counter2[j]=length(m)/max.iter
}
#----------------------------------------------------------------
design.opt=cbind(design1.uniq,counter,counter2)
design.optF <- as.data.frame(design.opt)
design.optF

SIG0
min(sigma0hat)
max(sigma0hat)

SIG1
min(sigma1hat)
max(sigma1hat)

par(mfrow=c(1,1))
#des.plot(design.opt)
plot(seq(1:max.iter),maxdev.vec ,ylim=c(0,0.2), type = "p",xlab="iter",ylab=expression(delta),pch=16,col="blue")

plot(seq(1:max.iter), sigma0hat,ylim=c(0.1,0.5), type = "p",xlab="iter",ylab=expression(sigma[0]),pch=16,col="blue")
abline(h=SIG0,lty=2,col="red")

plot(seq(1:max.iter), sigma1hat,ylim=c(0.1,0.5), type = "p",xlab="iter",ylab=expression(sigma[1]),pch=16,col="blue")
abline(h=SIG1,lty=2,col="red")
###########################################################
TH0START
min(THETA.HAT[,1])
max(THETA.HAT[,1])

min(THETA.HAT[,2])
max(THETA.HAT[,2])

min(THETA.HAT[,3])
max(THETA.HAT[,3])

TH1START
min(THETA.HAT[,4])
max(THETA.HAT[,4])

min(THETA.HAT[,5])
max(THETA.HAT[,5])

min(THETA.HAT[,6])
max(THETA.HAT[,6])

par(mfrow=c(2,3))
#des.plot(design.opt)
plot(seq(1:max.iter),THETA.HAT[,1] ,ylim=c(6.5,9.5), type = "p",xlab="iter",ylab=expression(theta[01]),pch=16,col="blue")
abline(h=TH0START[1],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,2] ,ylim=c(2.9,11), type = "p",xlab="iter",ylab=expression(theta[02]),pch=16,col="blue")
abline(h=TH0START[2],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,3] ,ylim=c(2.4,4.5), type = "p",xlab="iter",ylab=expression(theta[03]),pch=16,col="blue")
abline(h=TH0START[3],lty=2,col="red")


plot(seq(1:max.iter),THETA.HAT[,4] ,ylim=c(7.9,9.7), type = "p",xlab="iter",ylab=expression(theta[11]),pch=16,col="blue")
abline(h=TH1START[1],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,5] ,ylim=c(5.4,11.4), type = "p",xlab="iter",ylab=expression(theta[12]),pch=16,col="blue")
abline(h=TH1START[2],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,6] ,ylim=c(9.3,12.5), type = "p",xlab="iter",ylab=expression(theta[13]),pch=16,col="blue")
abline(h=TH1START[3],lty=2,col="red")


