#Ds for non comp,when theta is thEstart,thEstart[1:3]
par(mfrow=c(1,1))
rm(list=ls())
set.seed(123456789)
library(BB)
library(mgcv)
library(stats)
library(plotfunctions)
library(numDeriv)
library(MASS) #generalized inverse

xstart = matrix(c(0.00, 0.00,
                  0.00, 30.00,
                  0.00, 60.00,
                  15.00, 0.00,
                  15.00, 30.00,
                  15.00, 60.00,
                  30.00, 0.00,
                  30.00, 30.00,
                  30.00, 60.00), nrow=9,ncol=2,byrow=TRUE)


xstart1=xstart[,1]
xstart2=xstart[,2]

n <- nrow(xstart)
wstart=c(rep((1/n),n))

th0start <- c(7.298, 4.386, 2.582)
s0start <- c(0.114, 0.233, 0.145)
th1start <- c(8.696, 8.066, 12.057)
s1start<- c(0.222, 0.488, 0.671)

thEstart <- c(7.4253, 4.6808, 3.0581,0.9636)
sEstart <- c(0.1298, 0.2724, 0.2815,0.0191)


TH0START<-c(7.298, 4.386, 2.582)
TH1START<- c(8.696, 8.066, 12.057)
SIG0<-0.1553
SIG1<-0.2272

THESTART <- c(7.4253, 4.6808, 3.0581,0.9636)
SIGE<-0.1526


x1g=seq(0,30,length=31)
x2g=seq(0,60,length=61)
grid=expand.grid(x1g,x2g)


iter=0
max.iter=500


colfunc <- colorRampPalette(c("lightblue","cornflowerblue", "darkblue"))
colorgrad <- colfunc(max.iter)

THETA.HAT=matrix(0,max.iter,4)
THETA.HATBBo=matrix(0,max.iter,4)
S1SEq= S0SEq = th1l=th0l=th0u=th1u=matrix(0,max.iter,3)
SESEq=matrix(0,max.iter,4)
num.max=numeric(max.iter)
norm.sum.crit.ds=sum.crit.ds=max.sen.crit.ds=sigmaEhat=sigma1hat=numeric(max.iter)

####################################################

# Model 0  (comp)
f0 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kic <- th[3]
  V * S / (Km * (1 + I/Kic) + S)
}

# Model 1  (non comp)
f1 <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Kin <- th[3]
  V * S / ((Km + S) * (1 + I/Kin))
}

# Model 2  (encompassing)
fE <- function(S, I, th){
  V <- th[1]
  Km <- th[2]
  Klm <- th[3]
  Lmbda <- th[4]
  V * S / ( Km *(1+I/Klm) + S * (1 + (1-Lmbda) * I/Klm))
}

#-------------------------------------------------------
SE1 <- 0
S11 <- 0
########################################################

par(mar=c(5.1, 4.1, 4.1, 4.1))
plot(xstart1, xstart2, type = "n",xlab="x1",ylab="x2",pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5); grid()
points(xstart1, xstart2,col=colorgrad[1], pch=16,cex=0.8)

gradientLegend(valRange=c(1,max.iter),color = c("lightblue","cornflowerblue", "darkblue"),
               nCol = 3,inside = FALSE, pos=.825,dec = 0,n.seg=3,cex.main=2, cex.lab=1.5, cex.axis=1.5)
#text(x=31.5, y = 62, lables=expression("Tttitle"))


y<-f0(xstart1, xstart2, TH0START)+rnorm(nrow(xstart), sd = SIG0)
for(i in 1:length(y)){
  if(y[i]<0) y[i]<-0
}

basia<-data.frame(y,xstart)
#------------------------------------------------------------------

while(iter< max.iter){
  iter=iter+1
  print(iter)
  #-----------------------------------------------------------------------------------------------------------------------
  #                                                        Theta.HAT
  #-----------------------------------------------------------------------------------------------------------------------  
  
  mEpar.est<-nls(y~b1*basia[,2]/(b2*(1+basia[,3]/b3)+basia[,2]*(1+(1-b4)*basia[,3]/b3)),algorithm="port",lower=c(0.001,0.001,0.001,0.0001),upper=c(Inf,Inf,Inf,0.965), start= list(b1=thEstart[1],b2=thEstart[2],b3=thEstart[3],b4=thEstart[4]), data=basia)
  THETA.HAT[iter,]=thEstart<-summary(mEpar.est)$parameters[,1]
  SESEq[iter,] = sEstart<-summary(mEpar.est)$parameters[,2]
  sigmaEhat[iter]<-sqrt(sum(residuals(mEpar.est)^2)/(nrow(basia)-4))
  
  
  #-----------------------------------------------------------------------------------------------------------------------
  #                                                        X.HAT
  #-----------------------------------------------------------------------------------------------------------------------  
  
  #-----------------------------------------------------
  #F0.full <- matrix(0, nrow = nrow(xstart), ncol = 3)
  #F1.full <- matrix(0, nrow = nrow(xstart), ncol = 3)
  
  F.deriv <- function(thE,support){
    
    FE3.full <- matrix(0, nrow = nrow(support), ncol = 3)
    FE.full <- matrix(0, nrow = nrow(support), ncol = 4)
    
    x1 <- support[,1]
    x2 <- support[,2]
    
    a <- thE[1] * x1 
    b <- 1 + x2 / thE[3]
    cc <- 1 + (1-0.9636) * x2 / thE[3]
    d <- (b * thE[2]) + (x1 * cc)
    FE3.full[,1] <- x1 / d
    FE3.full[,2] <- -a / d^2 * b
    FE3.full[,3] <- a / d^2 * ((thE[2] + x1 * (1-0.9636)) * x2 / thE[3]^2)
    
    
    
    a <- thE[1] * x1 
    b <- 1 + x2 / thE[3]
    cc <- 1 + (1-thE[4]) * x2 / thE[3]
    d <- (b * thE[2]) + (x1 * cc)
    FE.full[,1] <- x1 / d
    FE.full[,2] <- -a / d^2 * b
    FE.full[,3] <- a / d^2 * ((thE[2] + x1 * (1-thE[4])) * x2 / thE[3]^2)
    FE.full[,4] <- a / d^2 * (x1 * x2 / thE[3] )
    
    return(list(FE3.full=FE3.full,FE.full=FE.full))
  }
  
  deriv.result <- F.deriv(thEstart,xstart)
  FE.full.mat <- deriv.result$FE.full
  FE3.full.mat <- deriv.result$FE3.full
  
  
  
  #W <- diag(wstart)
  M.mat <- t(FE.full.mat) %*% FE.full.mat
  ME3.mat <- t(FE3.full.mat) %*% FE3.full.mat  
  
  
  ds.funct<-function(xx1,xx2){
    
    f0.full <- matrix(0, nrow = 1, ncol = 3)
    f1.full <- matrix(0, nrow = 1, ncol = 3)
    fE3.full <- matrix(0, nrow = 1, ncol = 3)
    fE.full <- matrix(0, nrow = 1, ncol = 4)
    
    a <- thEstart[1] * xx1 
    b <- 1 + xx2 / thEstart[3]
    cc <- 1 + (1-0.9636) * xx2 / thEstart[3]
    d <- (b * thEstart[2]) + (xx1 * cc)
    fE3.full[1] <- xx1 / d
    fE3.full[2] <- -a / d^2 * b
    fE3.full[3] <- a / d^2 * ((thEstart[2] + xx1 * (1-0.9636)) * xx2 / thEstart[3]^2)
    
    
    a <- thEstart[1] * xx1 
    b <- 1 + xx2 / thEstart[3]
    cc <- 1 + (1-thEstart[4]) * xx2 / thEstart[3]
    d <- (b * thEstart[2]) + (xx1 * cc)
    fE.full[1] <- xx1 / d
    fE.full[2] <- -a / d^2 * b
    fE.full[3] <- a / d^2 * ((thEstart[2] + xx1 * (1-thEstart[4])) * xx2 / thEstart[3]^2)
    fE.full[4] <- a / d^2 * (xx1 * xx2 / thEstart[3] )
    
    
    xx=matrix(c(xx1,xx2),1,2)
    
    d<-fE.full%*%ginv(M.mat)%*%t(fE.full)-fE3.full%*%ginv(ME3.mat)%*%t(fE3.full)
    d
  }
  d.value<-mapply(ds.funct,grid[,1],grid[,2])
  
  max.sen.crit.ds[iter]<-max(d.value)
  xnew<-c(grid[which.max(d.value),1],grid[which.max(d.value),2])
  
  #-----------------------------------------------------
  xstart<-rbind(xstart,xnew)
  
  deriv.result1 <- F.deriv(thEstart,xstart)
  FFE.full.mat <- deriv.result1$FE.full
  FFE3.full.mat <- deriv.result1$FE3.full
  
  
  #W <- diag(wstart)
  MM.mat <- t(FFE.full.mat)  %*% FFE.full.mat
  MME3.mat <- t(FFE3.full.mat)  %*%  FFE3.full.mat
  Cri.val <- det(MM.mat)/det(MME3.mat)
  sum.crit.ds[iter] <- Cri.val
  norm.sum.crit.ds[iter] <- Cri.val/nrow(xstart)
  
  
  ynew<-f0(xnew[1], xnew[2], TH0START)+rnorm(1, sd = SIG0)
  if(ynew<0) ynew<-0
  
  y<-c(y,ynew) 
  
  
  cexxx=(length(which(xstart[,1]==xnew[1]&xstart[,2]==xnew[2])))^(1/2)
  points(xnew[1], xnew[2], type = "p",col=colorgrad[iter], pch=16,cex=0.8*cexxx,cex.main=2, cex.lab=1.5, cex.axis=1.5 )
  
  basia<-data.frame(y,xstart)
  
  alpha=1/(iter+1)
  wstart=c(((1-alpha)*wstart),alpha)
  design=cbind(xstart,wstart)
  n=nrow(xstart)
  
  
} 
#----------------------------------------------------------------
design1.uniq=uniquecombs(xstart)
count1=attr(design1.uniq,"index")
count2=unique(sort(count1))
#----------------------------------------------------------------
counter=counter2=numeric(nrow(design1.uniq))
for(j in 1:length(count2)){
  m=which(count1==count2[j])
  #weight[j]=sum(design[m,3])
  counter[j]=length(m)
  counter2[j]=length(m)/max.iter
}
#----------------------------------------------------------------
design.opt=cbind(design1.uniq,counter,counter2)
design.optF <- as.data.frame(design.opt)
design.optF
#################################
cc1<-which(y==0)
sum(cc1) 

cc2<-numeric(length(THESTART))
for(k in 1:length(THESTART)){
  ccc<-which(THETA.HAT[,k]==0.001)
  cc2[k]<-sum(ccc) 
} 
cc2
################################

SIG0
min(sigmaEhat)
max(sigmaEhat)
max(norm.sum.crit.ds)
max(norm.sum.crit.ds)/13

par(mfrow=c(1,1))
plot(seq(1:max.iter), max.sen.crit.ds , type = "p",xlab="iter",ylab="Max.sen",pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
plot(seq(1:max.iter),sum.crit.ds , type = "p",xlab="iter",ylab="Criterion",pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
plot(seq(1:max.iter),norm.sum.crit.ds , type = "p",ylim=c(0,4),xlab="iter",ylab="Norm.Criterion Ds",pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
abline(h=max(norm.sum.crit.ds),lty=2,col="red")


plot(seq(1:max.iter),norm.sum.crit.ds/13 , type = "p",ylim=c(0,0.3),xlab="iter",ylab="Norm.Criterion",pch=16,col="blue")
abline(h=median(norm.sum.crit.ds/13),lty=2,col="red")

quantile(norm.sum.crit.ds)
per0.5 <- quantile(norm.sum.crit.ds)[3]-quantile(norm.sum.crit.ds)[1]
per0.5 / (max(norm.sum.crit.ds)-min(norm.sum.crit.ds))

which(norm.sum.crit.ds >= 3*norm.sum.crit.ds[1])[1]
length(which(norm.sum.crit.ds >= 3*norm.sum.crit.ds[1]))
boxplot(norm.sum.crit.ds)

plot(seq(1:max.iter), sigmaEhat-0.025,ylim=c(0,0.6), type = "p",xlab="iter",ylab=expression(sigma[2]),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
abline(h=SIG0,lty=2,col="red")
#################################
plot(seq(1:max.iter),SESEq[,1] , type = "p",xlab="iter",ylab=expression(tilde(sigma[2])),ylim=c(0,3),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
points(seq(1:max.iter),SESEq[,2] , type = "p",xlab="iter",pch=16,col="red",cex.main=2, cex.lab=1.5, cex.axis=1.5)
points(seq(1:max.iter),SESEq[,3] , type = "p",xlab="iter",pch=16,col="darkgreen",cex.main=2, cex.lab=1.5, cex.axis=1.5)
points(seq(1:max.iter),SESEq[,4] , type = "p",xlab="iter",pch=16,col="black",cex.main=2, cex.lab=1.5, cex.axis=1.5)
#abline(h=SIGE,lty=2,col="red")
lgtxt0=c(expression(paste(tilde(sigma),"_21",sep="")), 
         expression(paste(tilde(sigma),"_22",sep="")),
         expression(paste(tilde(sigma),"_23",sep="")),
         expression(paste(tilde(sigma),"_24",sep=""))
)

legend("topright",legend=lgtxt0,col=c("blue","red","darkgreen","black"),pch=16,bty="n",cex=1.5, pt.cex = 1) 

which(SESEq[,1] <= SIGE)[1]
which(SESEq[,2] <= SIGE)[1]
which(SESEq[,3] <= SIGE)[1]
#################################
TH0START
min(THETA.HAT[,1])
max(THETA.HAT[,1])

min(THETA.HAT[,2])
max(THETA.HAT[,2])

min(THETA.HAT[,3])
max(THETA.HAT[,3])

min(THETA.HAT[,4])
max(THETA.HAT[,4])

min(THETA.HAT)
max(THETA.HAT)
TH0START


par(mfrow=c(1,1))
plot(seq(1:max.iter),THETA.HAT[,1] ,ylim=c(min(THETA.HAT),max(THETA.HAT)+1), type = "p",xlab="iter",ylab=expression(theta[21]),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
abline(h=THESTART[1],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,2] ,ylim=c(min(THETA.HAT),max(THETA.HAT)+1), type = "p",xlab="iter",ylab=expression(theta[22]),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
abline(h=THESTART[2],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,3] ,ylim=c(min(THETA.HAT),max(THETA.HAT)+1), type = "p",xlab="iter",ylab=expression(theta[23]),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
abline(h=THESTART[3],lty=2,col="red")

plot(seq(1:max.iter),THETA.HAT[,4] ,ylim=c(0,1), type = "p",xlab="iter",ylab=expression(lambda),pch=16,col="blue",cex.main=2, cex.lab=1.5, cex.axis=1.5)
#abline(h=THESTART[4],lty=2,col="red")




